include "./constants.circom"
include "./lib/bitify.circom";

// TODO: i suggest remove this component and let each child op component to do its own decoding
/**
 * @input in - {Array(Field)} - encoded transaction
 */

function TxLength() { return <%= codegen.config.commonPayload.length %>; }
function FloatLength() { return <%= codegen.config.floatLength %>;}

template DecodeTx(balanceLevels, orderLevels, accountLevels) {
    //TODO: we should also have levels for token tree?
    var tokenLevels = 16;

    signal input in[TxLength()];

    <% for(const item of codegen.config.commonPayload) { %>
    signal output <%= item %>;<% } %>

    //currently only the least packing for transfer tx ...
    //so accountID * 2 + tokenID + amount
    signal output encodedTxData[accountLevels*2 + tokenLevels + FloatLength()];

    component encodeAccount1 = Num2Bits(accountLevels);
    component encodeAccount2 = Num2Bits(accountLevels);
    component encodeTokenID = Num2Bits(tokenLevels);
    component encodeAmount = Num2Bits(FloatLength());

    <% for(const idx in codegen.config.commonPayload) { %>
    <%= codegen.config.commonPayload[idx] %> <== in[<%= idx %>];<% } %>

    encodeAccount1.in <== accountID1;
    encodeAccount2.in <== accountID2;
    encodeTokenID.in <== tokenID1;
    //amount is purposed to be 40bit-float, enforce error on overflowed
    encodeAmount.in <== amount;

    var i;
    for (i = 0; i < accountLevels; i++) {
        encodedTxData[i] <== encodeAccount1.out[i];
        encodedTxData[i+accountLevels] <== encodeAccount2.out[i];
    }

    for (i = 0; i < tokenLevels; i++) {
        encodedTxData[i+accountLevels*2] <== encodeTokenID.out[i];
    }

    for (i = 0; i < FloatLength(); i++) {
        encodedTxData[i+accountLevels*2+tokenLevels] <== encodeAmount.out[i];
    }

}
